use super::nodes::*;
use super::lexer::{Token, LexicalError};

grammar<'input>(input: &'input str);

// templates
SepVec<T, C>: Vec<T> = {
    <v:(<T> C)*> => v,
    <v:(<T> C)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

SepVecEmpty<T, C>: Vec<T> = {
    <v:(<T> Repeated<C>)*> => v,
    <v:(<T> Repeated<C>)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
};

Repeated<C>: C = {
    <r:C> => r,
    Repeated<C> <r:C> => r,
}

// syntax
pub Source: Statements = {
    SepVecEmpty<Statement, ";"> => Statements(<>),
    Repeated<";"> <l:SepVecEmpty<Statement, ";">> => Statements(l),
}

Statement: Statement = {
    OpExp => Statement::NodeTree(<>),
}

OpExp: Node = {
    Op0,
}

Op0: Node = {
    <e1:Op0> <l:@L> "or" <r:@R> <e2:Op1> => Node::LogicalOr(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op1,
}

Op1: Node = {
    <e1:Op1> <l:@L> "and" <r:@R> <e2:Op2> => Node::LogicalAnd(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op2,
}

Op2: Node = {
    <e1:Op2> <l:@L> "==" <r:@R> <e2:Op3> => Node::Equality(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op2> <l:@L> "~=" <r:@R> <e2:Op3> => Node::Inequality(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op2> <l:@L> "<"  <r:@R> <e2:Op3> => Node::LessThan(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op2> <l:@L> ">"  <r:@R> <e2:Op3> => Node::GreaterThan(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op2> <l:@L> "<=" <r:@R> <e2:Op3> => Node::LessOrEqual(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op2> <l:@L> ">=" <r:@R> <e2:Op3> => Node::GreaterOrEqual(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op3,
}

Op3: Node = {
    <e1:Op3> <l:@L> "|" <r:@R> <e2:Op4> => Node::BitwiseOr(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op4,
}

Op4: Node = {
    <e1:Op4> <l:@L> "~" <r:@R> <e2:Op5> => Node::BitwiseXor(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op5,
}

Op5: Node = {
    <e1:Op5> <l:@L> "&" <r:@R> <e2:Op6> => Node::BitwiseAnd(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op6,
}

Op6: Node = {
    <e1:Op6> <l:@L> "<<" <r:@R> <e2:Op7> => Node::LeftShift(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op6> <l:@L> ">>" <r:@R> <e2:Op7> => Node::RightShift(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op7,
}

Op7: Node = {
    <e1:Op7> <l:@L> ".." <r:@R> <e2:Op8> => Node::Concatenation(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op8,
}

Op8: Node = {
    <e1:Op8> <l:@L> "+" <r:@R> <e2:Op9> => Node::Addition(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op8> <l:@L> "-" <r:@R> <e2:Op9> => Node::Subtraction(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op9,
}

Op9: Node = {
    <e1:Op9> <l:@L> "*"  <r:@R> <e2:Op10> => Node::Multiplication(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op9> <l:@L> "/"  <r:@R> <e2:Op10> => Node::Division(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op9> <l:@L> "//" <r:@R> <e2:Op10> => Node::FloorDivision(Loc(l, r), Box::new(e1), Box::new(e2)),
    <e1:Op9> <l:@L> "%"  <r:@R> <e2:Op10> => Node::Modulo(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op10,
}

Op10: Node = {
    <l:@L> "not" <r:@R> <e:Op10> => Node::UnaryNot(Loc(l, r), Box::new(e)),
    <l:@L> "#"   <r:@R> <e:Op10> => Node::UnaryLength(Loc(l, r), Box::new(e)),
    <l:@L> "-"   <r:@R> <e:Op10> => Node::UnaryMinus(Loc(l, r), Box::new(e)),
    <l:@L> "~"   <r:@R> <e:Op10> => Node::UnaryBitwiseXor(Loc(l, r), Box::new(e)),
    Op11,
}

Op11: Node = {
    <e1:Op11> <l:@L> "^" <r:@R> <e2:Exp> => Node::Exponentiation(Loc(l, r), Box::new(e1), Box::new(e2)),
    Exp,
}

Exp: Node = {
    TableConstructor,
    // LiteralString
    // FunctionDef
    PrefixExp,
    <l:@L> "nil" <r:@R>           => Node::Nil(Loc(l, r)),
    <l:@L> "false" <r:@R>         => Node::False(Loc(l, r)),
    <l:@L> "true" <r:@R>          => Node::True(Loc(l, r)),
    <l:@L> "..." <r:@R>           => Node::VarArg(Loc(l, r)),
    <l:@L> <s:Numeral> <r:@R>     => Node::Numeral(Loc(l, r), s.parse::<f64>().unwrap()),
}

PrefixExp: Node = {
    Var,
    // FunctionCall,
    <l:@L> "(" <e:OpExp> ")" <r:@R> => Node::RoundBrackets(Loc(l, r), Box::new(e)),
}

// FunctionCall: Node = {
//     PrefixExp Args => Node::,
//     // PrefixExp Args =>,
// }
//
Var: Node = {
    <l:@L> <s:LexVariable> <r:@R> => Node::Var(Loc(l, r), s.to_string()),
    <l:@L> <e1:PrefixExp> "[" <e2:OpExp> "]" <r:@R> => Node::TableIndex(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:PrefixExp> "." <s:LexVariable> <r:@R> => Node::TableMember(Loc(l, r), Box::new(e1), s.to_string()),
}

TableConstructor: Node = {
    <l:@L> "{" <e:FieldList> "}" <r:@R> => Node::TableConstructor(Loc(l, r), Box::new(e)),
}

FieldList: Node = {
    <l:@L> <v:SepVec<Field, FieldSep>> <r:@R> => Node::Fields(Loc(l, r), v),
}

Field: Node = {
    <l:@L> "[" <e1:OpExp> "]" "=" <e2:OpExp> <r:@R> => Node::FieldNamedBracket(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Var> "=" <e2:OpExp> <r:@R>           => Node::FieldNamed(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e:OpExp> <r:@R>                         => Node::FieldSequential(Loc(l, r), Box::new(e)),
}

FieldSep = {
    ",",
    ";",
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "^"     => Token::OpExponentiation,
        "not"   => Token::OpLogicalNot,
        "#"     => Token::OpLength,
        "*"     => Token::OpMultiplication,
        "/"     => Token::OpDivision,
        "//"    => Token::OpFloorDivision,
        "%"     => Token::OpModulo,
        "+"     => Token::OpAddition,
        "-"     => Token::Minus,
        ".."    => Token::OpConcatenation,
        "<<"    => Token::OpLeftShift,
        ">>"    => Token::OpRightShift,
        "&"     => Token::OpBitwiseAnd,
        "~"     => Token::Tilde,
        "|"     => Token::OpBitwiseOr,
        "=="    => Token::OpEquality,
        "~="    => Token::OpInequality,
        "<"     => Token::OpLessThan,
        ">"     => Token::OpGreaterThan,
        "<="    => Token::OpLessOrEqual,
        ">="    => Token::OpGreaterOrEqual,
        "and"   => Token::OpLogicalAnd,
        "or"    => Token::OpLogicalOr,
        ";"     => Token::Semicolon,
        ","     => Token::Comma,
        "("     => Token::OpenRoundBracket,
        ")"     => Token::CloseRoundBracket,
        "["     => Token::OpenSquareBracket,
        "]"     => Token::CloseSquareBracket,
        "{"     => Token::OpenCurlyBracket,
        "}"     => Token::CloseCurlyBracket,
        "="     => Token::EqualsSign,
        "."     => Token::Period,
        "nil"   => Token::Nil,
        "false" => Token::False,
        "true"  => Token::True,
        "..."   => Token::VarArg,

        LexVariable => Token::Variable(<&'input str>),
        Numeral => Token::Number(<&'input str>),
    }
}
