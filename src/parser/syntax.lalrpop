use super::nodes::*;
use super::lexer::{Token, LexicalError};

grammar<'input>(input: &'input str);

// templates
// cannot be empty, no separators
SimpleVec<T>: Vec<T> = {
    <v:(<T>)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
}
// can be empty, no separators
SimpleEmptyVec<T>: Vec<T> = {
    => Vec::new(),
    <v:(<T>)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    },
}

// cannot be empty, no separator at the end
SepVec<T, C>: Vec<T> = {
    <e:T> => {
        let mut v = Vec::new();
        v.push(e);
        v
    },
    <e:T> <v:(C <T>)+> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

// can be empty, no separator at the end
SepEmptyVec<T, C>: Vec<T> = {
    => Vec::new(),
    <e:T> <v:(C <T>)*> => {
        let mut v = v;
        v.insert(0, e);
        v
    }
};

// cannot be empty, may have a separator at the end
SepVecEnd<T, C>: Vec<T> = {
    <e:T> C? => {
        let mut v = Vec::new();
        v.push(e);
        v
    },
    <e:T> <v:(C <T>)+> C? => {
        let mut v = v;
        v.insert(0, e);
        v
    },
};

// syntax
pub Chunk: Node = {
    Block,
}

Block: Node = {
    Stats,
    <l:@L> <n1:Stats> <n2:RetStat> <r:@R> => Node::StatsRetStat(Loc(l, r), Box::new(n1), Box::new(n2)),
}

Stats: Node = {
    <l:@L> <n:SimpleEmptyVec<Stat>> <r:@R> => Node::StatementList(Loc(l, r), n),
}

// Stat: Node = {
//     StatNext FunctionCall => Node::Empty(Loc(0, 0)),
//     // StatNext <n1:VarList> "=" <n2:ExpList> => Node::Empty(Loc(0, 0)),
//     StatNext,
// }

// StatNext: Node = {
Stat: Node = {
    <l:@L> ";" <r:@R>                            => Node::Empty(Loc(l, r)),
    <l:@L> <n1:VarList2> "=" <n2:ExpList> <r:@R> => Node::VarsExprs(Loc(l, r), Box::new(n1), Box::new(n2)), // problem
    FunctionCall2, // problem
    Label,
    <l:@L> "break" <r:@R>         => Node::Break(Loc(l, r)),
    <l:@L> "goto" <n:Name> <r:@R> => Node::GoTo(Loc(l, r), Box::new(n)),

    <l:@L> "do" <n:Block> "end" <r:@R>                   => Node::DoEnd(Loc(l, r), Box::new(n)),
    <l:@L> "while" <e:OpExp> "do" <n:Block> "end" <r:@R> => Node::While(Loc(l, r), Box::new(e), Box::new(n)),
    <l:@L> "repeat" <n:Block> "until" <e:OpExp> <r:@R>   => Node::Repeat(Loc(l, r), Box::new(n), Box::new(e)), // problem

    <l:@L> "if" <e1:OpExp> "then" <b1:Block> <n1:ElseIfThenVec> <empl:@L> <empr:@R> "end" <r:@R>
            => Node::IfThenElse(Loc(l, r), Box::new(e1), Box::new(b1), Box::new(n1), Box::new(Node::Empty(Loc(empl, empr)))),
    <l:@L> "if" <e1:OpExp> "then" <b1:Block> <n1:ElseIfThenVec> "else" <b2:Block> <r:@R> "end"
            => Node::IfThenElse(Loc(l, r), Box::new(e1), Box::new(b1), Box::new(n1), Box::new(b2)),

    <l:@L> "for" <n:Name> "=" <e1:OpExp> "," <e2:OpExp> "," <e3:OpExp> "do" <b:Block> "end" <r:@R>
            => Node::ForInt(Loc(l, r), Box::new(n), Box::new(e1), Box::new(e2), Box::new(e3), Box::new(b)),
    <l:@L> "for" <n:Name> "=" <e1:OpExp> "," <e2:OpExp> <empl:@L> <empr:@R> "do" <b:Block> "end" <r:@R>
            => Node::ForInt(Loc(l, r), Box::new(n), Box::new(e1), Box::new(e2), Box::new(Node::Empty(Loc(l, r))), Box::new(b)),
    <l:@L> "for" <n:NameList> "in" <e:ExpList> "do" <b:Block> "end" <r:@R>
            => Node::ForRange(Loc(l, r), Box::new(n), Box::new(e), Box::new(b)),

    <l:@L> "function" <n1:FuncName> <n2:FuncBody> <r:@R>     => Node::FuncDecl(Loc(l, r), Box::new(n1), Box::new(n2)),
    <l:@L> "local" "function" <n1:Name> <n2:FuncBody> <r:@R> => Node::FuncDecl(Loc(l, r), Box::new(n1), Box::new(n2)),

    <l:@L> "local" <n1:NameList> "=" <n2:ExpList> <r:@R>    => Node::LocalNamesExprs(Loc(l, r), Box::new(n1), Box::new(n2)), // problem
    <l:@L> "local" <n1:NameList> <empl:@L> <empr:@R> <r:@R> => Node::LocalNamesExprs(Loc(l, r), Box::new(n1), Box::new(Node::Empty(Loc(empl, empr)))),
}

ElseIfThenVec: Node = {
    <l:@L> <v:SimpleEmptyVec<ElseIfThen>> <r:@R> => Node::ElseIfThenVec(Loc(l, r), v),
}

ElseIfThen: Node = {
    <l:@L> "elseif" <e:OpExp> "then" <b:Block> <r:@R> => Node::ElseIfThen(Loc(l, r), Box::new(e), Box::new(b)),
}

RetStat: Node = {
    <l:@L> "return" <emp:@L> <r:@R>                => Node::RetStat(Loc(l, r), Box::new(Node::Empty(Loc(emp, r)))),
    <l:@L> "return" <n:ExpList> <r:@R>             => Node::RetStat(Loc(l, r), Box::new(n)),
    <l:@L> "return" <empl:@L> <empr:@R> ";" <r:@R> => Node::RetStat(Loc(l, r), Box::new(Node::Empty(Loc(empl, empr)))),
    <l:@L> "return" <n:ExpList> ";" <r:@R>         => Node::RetStat(Loc(l, r), Box::new(n)),
}

Label: Node = {
    <l:@L> "::" <n:Name> "::" <r:@R> => Node::Label(Loc(l, r), Box::new(n)),
}

FuncName: Node = {
    <l:@L> <v:SepVec<Name, ".">> <r:@R>              => Node::FuncName(Loc(l, r), v, Box::new(Node::Empty(Loc(r, r)))),
    <l:@L> <v:SepVec<Name, ".">> ":" <n:Name> <r:@R> => Node::FuncName(Loc(l, r), v, Box::new(n)),
}

VarList: Node = {
    <l:@L> <n:SepVec<Var, ",">> <r:@R> => Node::VarList(Loc(l, r), n),
}

VarList2: Node = {
    <l:@L> <n:SepVec<Var2, ",">> <r:@R> => Node::VarList(Loc(l, r), n),
}


// ---------------------------

FunctionCall2: Node = {
    VarOrExp2,
}

PrefixExp2: Node = {
    VarOrExp2,
}

VarOrExp2 = {
    Var2,
}

Var2: Node = {
    Name,
    <l:@L> <n1:Name> <n2:VarSuffixList> <r:@R> => Node::Var(Loc(l, r), Box::new(n1), Box::new(n2)),
}

PrefixExp: Node = {
    VarOrExp,
}

FunctionCall: Node = {
    VarOrExp,
}

VarOrExp = {
    Var,
    "(" <e:OpExp> ")" => Node::RoundBrackets(Loc(0, 0), Box::new(e)),
}

Var: Node = {
    Name,
    <l:@L> <n1:Name> <n2:VarSuffixList> <r:@R> => Node::Var(Loc(l, r), Box::new(n1), Box::new(n2)),
    "(" <e:OpExp> ")" <n:VarSuffixList>  => Node::VarRoundSuffix(Loc(0, 0), Box::new(e), Box::new(n)),
}

VarSuffixList: Node = {
    <v:SimpleVec<VarSuffix>> => Node::VarSuffixList(Loc(0, 0), v),
}

VarSuffix: Node = {
    "[" <e:OpExp> "]" => Node::TableIndex(Loc(0, 0), Box::new(e)),
    "." <n:Name>      => Node::TableMember(Loc(0, 0), Box::new(n)),
    Args,
    ":" <n1:Name> <n2:Args> => Node::FnMethodCall(Loc(0, 0), Box::new(n1), Box::new(n2)),
}

// ---------------------------

NameList: Node = {
    <l:@L> <n:SepVec<Name, ",">> <r:@R> => Node::NameList(Loc(l, r), n),
}

ExpList: Node = {
    <l:@L> <n:SepVec<OpExp, ",">> <r:@R> => Node::ExpList(Loc(l, r), n),
}

Exp: Node = {
    <l:@L> "nil" <r:@R>       => Node::Nil(Loc(l, r)),
    <l:@L> "false" <r:@R>     => Node::False(Loc(l, r)),
    <l:@L> "true" <r:@R>      => Node::True(Loc(l, r)),
    <l:@L> <s:Numeral> <r:@R> => Node::Numeral(Loc(l, r), s.parse::<f64>().unwrap()),
    StringLiteral,
    <l:@L> "..." <r:@R> => Node::VarArg(Loc(l, r)),
    FunctionDef,
    PrefixExp,
    TableConstructor,
}

Args: Node = {
    <l:@L> "(" <e:ExpList> ")" <r:@R>         => Node::RoundBrackets(Loc(l, r), Box::new(e)),
    <l:@L> "(" <empl:@L> <empr:@R> ")" <r:@R> => Node::RoundBrackets(Loc(l, r), Box::new(Node::Empty(Loc(empl, empr)))),
    TableConstructor,
    StringLiteral,
}

FunctionDef: Node = {
    <l:@L> "function" <n:FuncBody> <r:@R> => Node::FunctionDef(Loc(l, r), Box::new(n)),
}

FuncBody: Node = {
    <l:@L> "(" <n1:ParList> ")" <n2:Block> "end" <r:@R> => Node::FuncBody(Loc(l, r), Box::new(n1), Box::new(n2)),
}

ParList: Node = {
    <l:@L> <n:SepEmptyVec<Par, ",">> <r:@R> => Node::ParList(Loc(l, r), n),
}

Par: Node = {
    Name,
    <l:@L> "..." <r:@R> => Node::VarArg(Loc(l, r)),
}

TableConstructor: Node = {
    <l:@L> "{" <e:FieldList> "}" <r:@R>       => Node::TableConstructor(Loc(l, r), Box::new(e)),
    <l:@L> "{" <empl:@L> <empr:@R> "}" <r:@R> => Node::TableConstructor(Loc(l, r), Box::new(Node::Empty(Loc(empl, empr)))),
}

FieldList: Node = {
    <l:@L> <v:SepVecEnd<Field, FieldSep>> <r:@R> => Node::Fields(Loc(l, r), v),
}

Field: Node = {
    <l:@L> "[" <e1:OpExp> "]" "=" <e2:OpExp> <r:@R> => Node::FieldNamedBracket(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Name> "=" <e2:OpExp> <r:@R>          => Node::FieldNamed(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e:OpExp> <r:@R>                         => Node::FieldSequential(Loc(l, r), Box::new(e)),
}

FieldSep = {
    ",",
    ";",
}

OpExp: Node = {
    Op0,
}

Op0: Node = {
    <l:@L> <e1:Op0> "or" <e2:Op1> <r:@R> => Node::LogicalOr(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op1,
}

Op1: Node = {
    <l:@L> <e1:Op1> "and" <e2:Op2> <r:@R> => Node::LogicalAnd(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op2,
}

Op2: Node = {
    <l:@L> <e1:Op2> "==" <e2:Op3> <r:@R> => Node::Equality(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op2> "~=" <e2:Op3> <r:@R> => Node::Inequality(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op2> "<"  <e2:Op3> <r:@R> => Node::LessThan(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op2> ">"  <e2:Op3> <r:@R> => Node::GreaterThan(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op2> "<=" <e2:Op3> <r:@R> => Node::LessOrEqual(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op2> ">=" <e2:Op3> <r:@R> => Node::GreaterOrEqual(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op3,
}

Op3: Node = {
    <l:@L> <e1:Op3> "|" <e2:Op4> <r:@R> => Node::BitwiseOr(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op4,
}

Op4: Node = {
    <l:@L> <e1:Op4> "~" <e2:Op5> <r:@R> => Node::BitwiseXor(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op5,
}

Op5: Node = {
    <l:@L> <e1:Op5> "&" <e2:Op6> <r:@R> => Node::BitwiseAnd(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op6,
}

Op6: Node = {
    <l:@L> <e1:Op6> "<<" <e2:Op7> <r:@R> => Node::LeftShift(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op6> ">>" <e2:Op7> <r:@R> => Node::RightShift(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op7,
}

// right-associative
Op7: Node = {
    <l:@L> <e1:Op8> ".." <e2:Op7> <r:@R> => Node::Concatenation(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op8,
}

Op8: Node = {
    <l:@L> <e1:Op8> "+" <e2:Op9> <r:@R> => Node::Addition(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op8> "-" <e2:Op9> <r:@R> => Node::Subtraction(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op9,
}

Op9: Node = {
    <l:@L> <e1:Op9> "*"  <e2:Op10> <r:@R> => Node::Multiplication(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op9> "/"  <e2:Op10> <r:@R> => Node::Division(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op9> "//" <e2:Op10> <r:@R> => Node::FloorDivision(Loc(l, r), Box::new(e1), Box::new(e2)),
    <l:@L> <e1:Op9> "%"  <e2:Op10> <r:@R> => Node::Modulo(Loc(l, r), Box::new(e1), Box::new(e2)),
    Op10,
}

Op10: Node = {
    <l:@L> "not" <e:Op11> <r:@R> => Node::UnaryNot(Loc(l, r), Box::new(e)),
    <l:@L> "#"   <e:Op11> <r:@R> => Node::UnaryLength(Loc(l, r), Box::new(e)),
    <l:@L> "-"   <e:Op11> <r:@R> => Node::UnaryMinus(Loc(l, r), Box::new(e)),
    <l:@L> "~"   <e:Op11> <r:@R> => Node::UnaryBitwiseXor(Loc(l, r), Box::new(e)),
    Op11,
}

// right-associative
Op11: Node = {
    <l:@L> <e1:Exp> "^" <e2:Op11> <r:@R> => Node::Exponentiation(Loc(l, r), Box::new(e1), Box::new(e2)),
    Exp,
}

Name: Node = {
    <l:@L> <s:LexVariable> <r:@R> => Node::Name(Loc(l, r), s.to_string()),
}

StringLiteral: Node = {
    <l:@L> <s:NormalStringLiteral> <r:@R> => Node::NormalStringLiteral(Loc(l, r), s.to_string()),
    <l:@L> <s:CharStringLiteral> <r:@R>   => Node::CharStringLiteral(Loc(l, r), s.to_string()),
}

extern {
    type Location = usize;
    type Error = LexicalError;

    enum Token<'input> {
        "^"   => Token::OpExponentiation,
        "not" => Token::OpLogicalNot,
        "#"   => Token::OpLength,
        "*"   => Token::OpMultiplication,
        "/"   => Token::OpDivision,
        "//"  => Token::OpFloorDivision,
        "%"   => Token::OpModulo,
        "+"   => Token::OpAddition,
        "-"   => Token::Minus,
        ".."  => Token::OpConcatenation,
        "<<"  => Token::OpLeftShift,
        ">>"  => Token::OpRightShift,
        "&"   => Token::OpBitwiseAnd,
        "~"   => Token::Tilde,
        "|"   => Token::OpBitwiseOr,
        "=="  => Token::OpEquality,
        "~="  => Token::OpInequality,
        "<"   => Token::OpLessThan,
        ">"   => Token::OpGreaterThan,
        "<="  => Token::OpLessOrEqual,
        ">="  => Token::OpGreaterOrEqual,
        "and" => Token::OpLogicalAnd,
        "or"  => Token::OpLogicalOr,
        ";"   => Token::Semicolon,
        ","   => Token::Comma,
        ":"   => Token::Colon,
        "::"  => Token::Label,
        "("   => Token::OpenRoundBracket,
        ")"   => Token::CloseRoundBracket,
        "["   => Token::OpenSquareBracket,
        "]"   => Token::CloseSquareBracket,
        "{"   => Token::OpenCurlyBracket,
        "}"   => Token::CloseCurlyBracket,
        "="   => Token::EqualsSign,
        "."   => Token::Period,

        "..."      => Token::VarArg,
        "break"    => Token::Break,
        "do"       => Token::Do,
        "else"     => Token::Else,
        "elseif"   => Token::ElseIf,
        "end"      => Token::End,
        "false"    => Token::False,
        "for"      => Token::For,
        "function" => Token::Function,
        "goto"     => Token::GoTo,
        "if"       => Token::If,
        "in"       => Token::In,
        "local"    => Token::Local,
        "nil"      => Token::Nil,
        "repeat"   => Token::Repeat,
        "return"   => Token::Return,
        "then"     => Token::Then,
        "true"     => Token::True,
        "until"    => Token::Until,
        "while"    => Token::While,

        LexVariable         => Token::Variable(<&'input str>),
        Numeral             => Token::Numeral(<&'input str>),
        NormalStringLiteral => Token::NormalStringLiteral(<&'input str>),
        CharStringLiteral   => Token::CharStringLiteral(<&'input str>),
    }
}
